{
  "version": 3,
  "sources": ["../../@lukemorales/query-key-factory/src/internals/assert-schema-keys.ts", "../../@lukemorales/query-key-factory/src/internals/omit-prototype.ts", "../../@lukemorales/query-key-factory/src/create-query-keys.ts", "../../@lukemorales/query-key-factory/src/create-query-key-store.ts", "../../@lukemorales/query-key-factory/src/create-mutation-keys.ts", "../../@lukemorales/query-key-factory/src/merge-query-keys.ts"],
  "sourcesContent": ["/**\n * @internal ensures no keys provided by the user starts with an _underscore `_`_\n */\nexport const assertSchemaKeys = (schema: Record<string, unknown>): string[] => {\n  const keys = Object.keys(schema).sort((a, b) => a.localeCompare(b));\n\n  const hasKeyInShapeOfInternalKey = keys.some((key) => key.startsWith('_'));\n\n  if (hasKeyInShapeOfInternalKey) {\n    throw new Error('Keys that start with \"_\" are reserved for Query Key Factory');\n  }\n\n  return keys;\n};\n", "/**\n * Create an object without inheriting anything from `Object.prototype`\n * @internal\n *\n * @see {@link https://github.com/trpc/trpc/blob/next/packages/server/src/core/internals/omitPrototype.ts tRPC repo for original code }\n */\nexport function omitPrototype<T extends Record<string, unknown>>(obj: T): T {\n  return Object.assign(Object.create(null), obj);\n}\n", "import type {\n  AnyQueryFactoryOutputCallback,\n  AnyQueryKey,\n  QueryFactorySchema,\n  QueryKeyFactoryResult,\n  ValidateFactory,\n} from './create-query-keys.types';\nimport { assertSchemaKeys, omitPrototype } from './internals';\nimport { type DefinitionKey } from './types';\n\nexport function createQueryKeys<Key extends string>(queryDef: Key): DefinitionKey<[Key]>;\nexport function createQueryKeys<Key extends string, Schema extends QueryFactorySchema>(\n  queryDef: Key,\n  schema: ValidateFactory<Schema>,\n): QueryKeyFactoryResult<Key, Schema>;\nexport function createQueryKeys<Key extends string, Schema extends QueryFactorySchema>(\n  queryDef: Key,\n  schema?: ValidateFactory<Schema>,\n): DefinitionKey<[Key]> | QueryKeyFactoryResult<Key, Schema> {\n  const defKey: DefinitionKey<[Key]> = {\n    _def: [queryDef] as const,\n  };\n\n  if (schema == null) {\n    return omitPrototype(defKey);\n  }\n\n  const transformSchema = <$Factory extends QueryFactorySchema>(factory: $Factory, mainKey: AnyQueryKey) => {\n    type $FactoryProperty = keyof $Factory;\n\n    const keys = assertSchemaKeys(factory);\n    return keys.reduce((factoryMap, factoryKey) => {\n      const value = factory[factoryKey];\n      const key = [...mainKey, factoryKey] as const;\n\n      const isReadonlyArray = (arg: unknown): arg is readonly any[] => Array.isArray(arg);\n\n      let yieldValue: any;\n\n      if (typeof value === 'function') {\n        const resultCallback: AnyQueryFactoryOutputCallback = (...args) => {\n          const result = value(...args);\n\n          if (isReadonlyArray(result)) {\n            return omitPrototype({\n              queryKey: [...key, ...result] as const,\n            });\n          }\n\n          const innerKey = [...key, ...result.queryKey] as const;\n\n          if ('queryFn' in result) {\n            // type $QueryFnContext = Omit<QueryFunctionContext<typeof innerKey, any>, 'queryKey'>;\n\n            const queryOptions = {\n              queryKey: innerKey,\n              queryFn: result.queryFn,\n            };\n\n            if ('contextQueries' in result) {\n              const transformedSchema = transformSchema(result.contextQueries, innerKey);\n\n              return omitPrototype({\n                _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n                ...queryOptions,\n              });\n            }\n\n            return omitPrototype({\n              ...queryOptions,\n            });\n          }\n\n          if ('contextQueries' in result) {\n            const transformedSchema = transformSchema(result.contextQueries, innerKey);\n\n            return omitPrototype({\n              _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n              queryKey: innerKey,\n            });\n          }\n\n          return omitPrototype({\n            queryKey: innerKey,\n          });\n        };\n\n        resultCallback._def = key;\n\n        yieldValue = resultCallback;\n      } else if (value == null) {\n        yieldValue = omitPrototype({\n          queryKey: key,\n        });\n      } else if (isReadonlyArray(value)) {\n        yieldValue = omitPrototype({\n          _def: key,\n          queryKey: [...key, ...value] as const,\n        });\n      } else if ('queryFn' in value) {\n        // type $QueryFnContext = Omit<QueryFunctionContext<typeof innerKey, any>, 'queryKey'>;\n\n        const innerDefKey = { ...(value.queryKey ? { _def: key } : undefined) };\n        const innerKey = [...key, ...(value.queryKey ?? [])] as const;\n\n        const queryOptions = {\n          queryKey: innerKey,\n          queryFn: value.queryFn,\n        };\n\n        if ('contextQueries' in value) {\n          const transformedSchema = transformSchema(value.contextQueries, innerKey);\n\n          yieldValue = omitPrototype({\n            _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n            ...innerDefKey,\n            ...queryOptions,\n          });\n        } else {\n          yieldValue = omitPrototype({ ...innerDefKey, ...queryOptions });\n        }\n      } else if ('contextQueries' in value) {\n        const innerDefKey = { ...(value.queryKey ? { _def: key } : undefined) };\n        const innerKey = [...key, ...(value.queryKey ?? [])] as const;\n\n        const transformedSchema = transformSchema(value.contextQueries, innerKey);\n\n        yieldValue = omitPrototype({\n          _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n          queryKey: innerKey,\n          ...innerDefKey,\n        });\n      } else {\n        const innerDefKey = { ...(value.queryKey ? { _def: key } : undefined) };\n        const innerKey = [...key, ...(value.queryKey ?? [])] as const;\n\n        yieldValue = omitPrototype({\n          queryKey: innerKey,\n          ...innerDefKey,\n        });\n      }\n\n      factoryMap.set(factoryKey, yieldValue);\n      return factoryMap;\n    }, new Map<$FactoryProperty, $Factory[$FactoryProperty]>());\n  };\n\n  const transformedSchema = transformSchema(schema as QueryFactorySchema, defKey._def);\n\n  return omitPrototype({\n    ...Object.fromEntries(transformedSchema),\n    ...defKey,\n  });\n}\n", "import { createQueryKeys } from './create-query-keys';\nimport type { QueryFactorySchema, QueryKeyFactoryResult } from './create-query-keys.types';\nimport type { DefinitionKey } from './types';\nimport { omitPrototype } from './internals';\n\ntype QueryKeyStoreSchema = Record<string, null | QueryFactorySchema>;\n\nexport type QueryKeyStore<StoreSchema extends QueryKeyStoreSchema> = {\n  [P in keyof StoreSchema & string]: StoreSchema[P] extends QueryFactorySchema ?\n    QueryKeyFactoryResult<P, StoreSchema[P]>\n  : DefinitionKey<[P]>;\n};\n\nexport function createQueryKeyStore<StoreSchema extends QueryKeyStoreSchema>(\n  schema: StoreSchema,\n): QueryKeyStore<StoreSchema> {\n  const keys = Object.keys(schema);\n\n  const store = keys.reduce((storeMap, key) => {\n    const factory = schema[key];\n\n    const result = factory ? createQueryKeys(key, factory) : createQueryKeys(key);\n\n    storeMap.set(key, result);\n    return storeMap;\n  }, new Map());\n\n  return omitPrototype(Object.fromEntries(store));\n}\n", "import type {\n  MutationFactorySchema,\n  MutationKeyFactoryResult,\n  AnyMutationFactoryOutputCallback,\n  ValidateFactory,\n  AnyMutationKey,\n} from './create-mutation-keys.types';\nimport { assertSchemaKeys, omitPrototype } from './internals';\nimport type { DefinitionKey } from './types';\n\n/**\n * @deprecated the type inference for this function is broken and will be fixed in the next patch version\n * or possibly removed and implemented differently in a major version\n */\nexport function createMutationKeys<Key extends string>(mutationDef: Key): DefinitionKey<[Key]>;\n/**\n * @deprecated the type inference for this function is broken and will be fixed in the next patch version\n * or possibly removed and implemented differently in a major version\n */\nexport function createMutationKeys<Key extends string, Schema extends MutationFactorySchema>(\n  mutationDef: Key,\n  schema: ValidateFactory<Schema>,\n): MutationKeyFactoryResult<Key, Schema>;\n/**\n * @deprecated the type inference for this function is broken and will be fixed in the next patch version\n * or possibly removed and implemented differently in a major version\n */\nexport function createMutationKeys<Key extends string, Schema extends MutationFactorySchema>(\n  mutationDef: Key,\n  schema?: ValidateFactory<Schema>,\n): DefinitionKey<[Key]> | MutationKeyFactoryResult<Key, Schema> {\n  const defKey: DefinitionKey<[Key]> = {\n    _def: [mutationDef] as const,\n  };\n\n  if (schema == null) {\n    return omitPrototype(defKey);\n  }\n\n  const transformSchema = <$Factory extends MutationFactorySchema>(factory: $Factory, mainKey: AnyMutationKey) => {\n    type $FactoryProperty = keyof $Factory;\n\n    const keys = assertSchemaKeys(factory);\n    return keys.reduce((factoryMap, factoryKey) => {\n      const value = factory[factoryKey];\n      const key = [...mainKey, factoryKey] as const;\n\n      const isReadonlyArray = (arg: unknown): arg is readonly any[] => Array.isArray(arg);\n\n      let yieldValue: any;\n\n      if (typeof value === 'function') {\n        const resultCallback: AnyMutationFactoryOutputCallback = (...args) => {\n          const result = value(...args);\n\n          if (isReadonlyArray(result)) {\n            return omitPrototype({\n              mutationKey: [...key, ...result] as const,\n            });\n          }\n\n          const innerKey = [...key, ...result.mutationKey] as const;\n\n          if ('mutationFn' in result) {\n            const queryOptions = {\n              mutationKey: innerKey,\n              mutationFn: result.mutationFn,\n            };\n\n            if ('contextMutations' in result) {\n              const transformedSchema = transformSchema(result.contextMutations, innerKey);\n\n              return omitPrototype({\n                _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n                ...queryOptions,\n              });\n            }\n\n            return omitPrototype({\n              ...queryOptions,\n            });\n          }\n\n          if ('contextMutations' in result) {\n            const transformedSchema = transformSchema(result.contextMutations, innerKey);\n\n            return omitPrototype({\n              _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n              mutationKey: innerKey,\n            });\n          }\n\n          return omitPrototype({\n            mutationKey: innerKey,\n          });\n        };\n\n        resultCallback._def = key;\n\n        yieldValue = resultCallback;\n      } else if (value == null) {\n        yieldValue = omitPrototype({\n          mutationKey: key,\n        });\n      } else if (isReadonlyArray(value)) {\n        yieldValue = omitPrototype({\n          _def: key,\n          mutationKey: [...key, ...value] as const,\n        });\n      } else if ('mutationFn' in value) {\n        const innerDefKey = { ...(value.mutationKey ? { _def: key } : undefined) };\n        const innerKey = [...key, ...(value.mutationKey ?? [])] as const;\n\n        const queryOptions = {\n          mutationKey: innerKey,\n          mutationFn: value.mutationFn,\n        };\n\n        if ('contextMutations' in value) {\n          const transformedSchema = transformSchema(value.contextMutations, innerKey);\n\n          yieldValue = omitPrototype({\n            _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n            ...innerDefKey,\n            ...queryOptions,\n          });\n        } else {\n          yieldValue = omitPrototype({ ...innerDefKey, ...queryOptions });\n        }\n      } else if ('contextMutations' in value) {\n        const innerDefKey = { ...(value.mutationKey ? { _def: key } : undefined) };\n        const innerKey = [...key, ...(value.mutationKey ?? [])] as const;\n\n        const transformedSchema = transformSchema(value.contextMutations, innerKey);\n\n        yieldValue = omitPrototype({\n          _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n          mutationKey: innerKey,\n          ...innerDefKey,\n        });\n      } else {\n        const innerDefKey = { ...(value.mutationKey ? { _def: key } : undefined) };\n        const innerKey = [...key, ...(value.mutationKey ?? [])] as const;\n\n        yieldValue = omitPrototype({\n          mutationKey: innerKey,\n          ...innerDefKey,\n        });\n      }\n\n      factoryMap.set(factoryKey, yieldValue);\n      return factoryMap;\n    }, new Map<$FactoryProperty, $Factory[$FactoryProperty]>());\n  };\n\n  const transformedSchema = transformSchema(schema, defKey._def);\n\n  return omitPrototype({\n    ...Object.fromEntries(transformedSchema),\n    ...defKey,\n  });\n}\n", "import { type AnyMutationKeyFactoryResult } from './create-mutation-keys.types';\nimport type { AnyQueryKeyFactoryResult } from './create-query-keys.types';\nimport { omitPrototype } from './internals';\nimport type { Prettify } from './types';\n\ntype StoreFromMergedQueryKeys<\n  QueryOrMutationKeyFactoryResults extends Array<AnyQueryKeyFactoryResult | AnyMutationKeyFactoryResult>,\n> =\n  QueryOrMutationKeyFactoryResults extends (\n    [\n      infer First extends AnyQueryKeyFactoryResult | AnyMutationKeyFactoryResult,\n      ...infer Rest extends AnyQueryKeyFactoryResult[] | AnyMutationKeyFactoryResult[],\n    ]\n  ) ?\n    { [P in First['_def'][0]]: First } & StoreFromMergedQueryKeys<Rest>\n  : {};\n\nexport function mergeQueryKeys<\n  QueryKeyFactoryResults extends Array<AnyQueryKeyFactoryResult | AnyMutationKeyFactoryResult>,\n>(...schemas: QueryKeyFactoryResults): Prettify<StoreFromMergedQueryKeys<QueryKeyFactoryResults>> {\n  const store = schemas.reduce((storeMap, current) => {\n    const [storeKey] = current._def;\n\n    storeMap.set(storeKey, { ...storeMap.get(storeKey), ...current });\n    return storeMap;\n  }, new Map());\n\n  return omitPrototype(Object.fromEntries(store));\n}\n"],
  "mappings": "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",
  "names": ["assertSchemaKeys", "schema", "keys", "a", "b", "key", "omitPrototype", "obj", "createQueryKeys", "queryDef", "defKey", "transformSchema", "factory", "mainKey", "factoryMap", "factoryKey", "value", "isReadonlyArray", "arg", "yieldValue", "resultCallback", "args", "result", "innerKey", "queryOptions", "transformedSchema", "innerDefKey", "createQueryKeyStore", "store", "storeMap", "createMutationKeys", "mutationDef", "mergeQueryKeys", "schemas", "current", "storeKey"]
}
